import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:expensease/app/data/models/expense_model.dart';
import 'package:expensease/app/data/providers/firebase_provider.dart';

/// ExpenseRepository handles all data operations related to expenses,
/// such as creating, fetching, and managing them within a group.
class ExpenseRepository {
  final FirebaseProvider _firebaseProvider;

  /// Constructor uses dependency injection for better testability and structure.
  ExpenseRepository({FirebaseProvider? provider})
      : _firebaseProvider = provider ?? FirebaseProvider();

  /// Returns a live stream of all expenses for a given group ID.
  Stream<List<ExpenseModel>> getExpensesStreamForGroup(String groupId) {
    try {
      return _firebaseProvider.getExpensesForGroup(groupId).map((snapshot) {
        return snapshot.docs
            .map((doc) => ExpenseModel.fromSnapshot(doc))
            .toList();
      });
    } catch (e) {
      // In case of an error setting up the stream, return an error stream.
      return Stream.error('Failed to get expenses stream.');
    }
  }

  /// Fetches a list of expenses within a specific date range for reporting.
  Future<List<ExpenseModel>> getExpensesForReport({
    required String groupId,
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      final snapshot = await _firebaseProvider.getExpensesForDateRange(
        groupId: groupId,
        startDate: startDate,
        endDate: endDate,
      );
      return snapshot.docs
          .map((doc) => ExpenseModel.fromSnapshot(doc))
          .toList();
    } catch (e) {
      // Re-throw a user-friendly exception to be handled by the controller.
      throw Exception('Failed to load report data.');
    }
  }

  /// Creates a new expense document in the 'expenses' sub-collection of a group.
  Future<void> addExpense({
    required String groupId,
    required String description,
    required double totalAmount,
    required DateTime date,
    required String paidById, // Renamed for clarity
    required Map<String, double> splitBetween, // Renamed for clarity
    String? category,
    String? notes,
    String? receiptUrl,
  }) async {
    try {
      // The repository is responsible for creating the model object.
      // The ID will be generated by Firestore, so we can leave it empty here.
      final newExpense = ExpenseModel(
        id: '', // Firestore will generate this
        description: description,
        totalAmount: totalAmount,
        date: date,
        paidById: paidById,
        splitBetween: splitBetween,
        category: category,
        notes: notes,
        receiptUrl: receiptUrl,
        createdAt: Timestamp.now(),
      );

      // The provider handles the actual database write operation.
      await _firebaseProvider.addExpense(groupId, newExpense);
    } catch (e) {
      throw Exception('Failed to add expense. Please try again.');
    }
  }

// TODO: Implement methods for updating and deleting expenses.
}